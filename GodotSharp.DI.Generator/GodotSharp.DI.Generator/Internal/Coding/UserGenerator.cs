using GodotSharp.DI.Generator.Internal.Data;
using GodotSharp.DI.Generator.Internal.Helpers;
using GodotSharp.DI.Shared;
using Microsoft.CodeAnalysis;
using TypeInfo = GodotSharp.DI.Generator.Internal.Data.TypeInfo;

namespace GodotSharp.DI.Generator.Internal.Coding;

/// <summary>
/// User 代码生成器
/// </summary>
internal static class UserGenerator
{
    public static void Generate(SourceProductionContext context, TypeNode node)
    {
        var type = node.TypeInfo;
        var namespaceName = type.Symbol.ContainingNamespace.ToDisplayString();
        var className = type.Symbol.Name;

        // 生成基础 DI 文件
        if (type.Role == TypeRole.User)
        {
            GenerateBaseDI(context, type, namespaceName, className);
        }

        // 生成 User 特定代码
        GenerateUserSpecific(context, type, namespaceName, className);
    }

    private static void GenerateBaseDI(
        SourceProductionContext context,
        TypeInfo type,
        string namespaceName,
        string className
    )
    {
        var f = new CodeFormatter();
        var isNode = type.Symbol.BaseType?.ToDisplayString().Contains("Godot.Node") ?? false;

        f.AppendLine("// <auto-generated/>");
        f.AppendLine($"namespace {namespaceName};");
        f.AppendLine();
        f.AppendLine($"partial class {className}");
        f.BeginBlock();

        if (isNode)
        {
            NodeDIGenerator.GenerateNodeDICode(f, type);
        }
        else
        {
            GenerateNonNodeDICode(f, type);
        }

        f.EndBlock();

        context.AddSource($"{className}.DI.g.cs", f.ToString());
    }

    private static void GenerateNonNodeDICode(CodeFormatter f, TypeInfo type)
    {
        f.AppendLine($"public void ResolveDependencies({GlobalNames.IScope} scope)");
        f.BeginBlock();
        {
            f.AppendLine("ResolveUserDependencies(scope);");
        }
        f.EndBlock();
    }

    private static void GenerateUserSpecific(
        SourceProductionContext context,
        TypeInfo type,
        string namespaceName,
        string className
    )
    {
        var injectMembersList = new System.Collections.Generic.List<MemberInfo>();
        var userMembersList = new System.Collections.Generic.List<MemberInfo>();

        foreach (var member in type.Members)
        {
            if (member.Kind == MemberKind.InjectField || member.Kind == MemberKind.InjectProperty)
            {
                injectMembersList.Add(member);
            }
            else if (
                member.Kind == MemberKind.UserMemberField
                || member.Kind == MemberKind.UserMemberProperty
            )
            {
                userMembersList.Add(member);
            }
        }

        // 如果既没有 Inject 成员也没有 UserMember，则不生成代码
        if (injectMembersList.Count == 0 && userMembersList.Count == 0)
            return;

        var f = new CodeFormatter();

        f.AppendLine("// <auto-generated/>");
        f.AppendLine($"namespace {namespaceName};");
        f.AppendLine();
        f.AppendLine($"partial class {className}");
        f.BeginBlock();

        if (type.ImplementsIServicesReady)
        {
            GenerateDependencyTracking(f, injectMembersList);
        }

        GenerateResolveUserDependencies(f, type, injectMembersList, userMembersList);

        f.EndBlock();

        context.AddSource($"{className}.DI.User.g.cs", f.ToString());
    }

    private static void GenerateDependencyTracking(
        CodeFormatter f,
        System.Collections.Generic.List<MemberInfo> injectMembersList
    )
    {
        f.AppendLine(
            $"private readonly {GlobalNames.HashSet}<{GlobalNames.Type}> _unresolvedDependencies = new()"
        );
        f.BeginBlock();
        {
            foreach (var member in injectMembersList)
            {
                f.AppendLine($"typeof({member.MemberType.ToDisplayString()}),");
            }
        }
        f.EndBlock(";");
        f.AppendLine();

        f.AppendLine("private void OnDependencyResolved<T>()");
        f.BeginBlock();
        {
            f.AppendLine("_unresolvedDependencies.Remove(typeof(T));");
            f.AppendLine("if (_unresolvedDependencies.Count == 0)");
            f.BeginBlock();
            {
                f.AppendLine($"(({GlobalNames.IServicesReady})this).OnServicesReady();");
            }
            f.EndBlock();
        }
        f.EndBlock();
        f.AppendLine();
    }

    private static void GenerateResolveUserDependencies(
        CodeFormatter f,
        TypeInfo type,
        System.Collections.Generic.List<MemberInfo> injectMembersList,
        System.Collections.Generic.List<MemberInfo> userMembersList
    )
    {
        // ResolveUserDependencies - 添加 IDE 隐藏特性
        f.AppendAttribute(IdeAttributes.EditorBrowsableNever);
        f.AppendLine($"private void ResolveUserDependencies({GlobalNames.IScope} scope)");
        f.BeginBlock();
        {
            // 先注入 [Inject] 成员
            foreach (var member in injectMembersList)
            {
                f.AppendLine(
                    $"scope.ResolveDependency<{member.MemberType.ToDisplayString()}>(dependency =>"
                );
                f.BeginBlock();
                {
                    f.AppendLine($"{member.Symbol.Name} = dependency;");

                    if (type.ImplementsIServicesReady)
                    {
                        f.AppendLine(
                            $"OnDependencyResolved<{member.MemberType.ToDisplayString()}>();"
                        );
                    }
                }
                f.EndBlock(");");
            }

            // 递归注入 UserMember
            foreach (var member in userMembersList)
            {
                f.AppendLine($"// 注入 User 成员: {member.Symbol.Name}");
                f.AppendLine($"if ({member.Symbol.Name} != null)");
                f.BeginBlock();
                {
                    f.AppendLine($"{member.Symbol.Name}.ResolveDependencies(scope);");
                }
                f.EndBlock();
            }
        }
        f.EndBlock();
    }
}
