//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace GodotSharpDI.SourceGenerator {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("GodotSharpDI.SourceGenerator.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to DI-relative class &apos;{0}&apos; must be declared as partial to enable code generation.
        /// </summary>
        internal static string C_DiClassMustBePartial {
            get {
                return ResourceManager.GetString("C_DiClassMustBePartial", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Host &apos;{0}&apos; cannot use [{1}].
        /// </summary>
        internal static string C_HostInvalidAttribute {
            get {
                return ResourceManager.GetString("C_HostInvalidAttribute", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Host &apos;{0}&apos; must inherit from Godot.Node.
        /// </summary>
        internal static string C_HostMustBeNode {
            get {
                return ResourceManager.GetString("C_HostMustBeNode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; has incorrect _Notification method signature. Expected: &apos;public override partial void _Notification(int what);&apos;.
        /// </summary>
        internal static string C_InvalidNotificationMethodSignature {
            get {
                return ResourceManager.GetString("C_InvalidNotificationMethodSignature", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; must define &apos;public override partial void _Notification(int what);&apos; in the script file attached to Node. This method is required for DI framework lifecycle management.
        /// </summary>
        internal static string C_MissingNotificationMethod {
            get {
                return ResourceManager.GetString("C_MissingNotificationMethod", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To use [Modules], Type &apos;{0}&apos; must implement IScope.
        /// </summary>
        internal static string C_OnlyScopeCanUseModules {
            get {
                return ResourceManager.GetString("C_OnlyScopeCanUseModules", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Scope &apos;{0}&apos; cannot use [{1}].
        /// </summary>
        internal static string C_ScopeInvalidAttribute {
            get {
                return ResourceManager.GetString("C_ScopeInvalidAttribute", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Scope &apos;{0}&apos; must specify [Modules].
        /// </summary>
        internal static string C_ScopeMissingModules {
            get {
                return ResourceManager.GetString("C_ScopeMissingModules", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Scope &apos;{0}&apos; must inherit from Godot.Node.
        /// </summary>
        internal static string C_ScopeMustBeNode {
            get {
                return ResourceManager.GetString("C_ScopeMustBeNode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Service &apos;{0}&apos; has exposed type &apos;{1}&apos;, but which is not implemented.
        /// </summary>
        internal static string C_ServiceExposedTypeNotImplemented {
            get {
                return ResourceManager.GetString("C_ServiceExposedTypeNotImplemented", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Service &apos;{0}&apos; exposed type &apos;{1}&apos; is a concrete class. Consider using an interface instead for better testability and loose coupling.
        /// </summary>
        internal static string C_ServiceExposedTypeShouldBeInterface {
            get {
                return ResourceManager.GetString("C_ServiceExposedTypeShouldBeInterface", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; implements IServicesReady but is not marked with [User].
        /// </summary>
        internal static string C_ServiceReadyNeedUser {
            get {
                return ResourceManager.GetString("C_ServiceReadyNeedUser", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Service &apos;{0}&apos; cannot inherit from Godot.Node, and must be non-abstract, non-static class type.
        /// </summary>
        internal static string C_ServiceTypeIsInvalid {
            get {
                return ResourceManager.GetString("C_ServiceTypeIsInvalid", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to User &apos;{0}&apos; cannot use [{1}].
        /// </summary>
        internal static string C_UserInvalidAttribute {
            get {
                return ResourceManager.GetString("C_UserInvalidAttribute", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to User &apos;{0}&apos; must inherit from Godot.Node.
        /// </summary>
        internal static string C_UserMustBeNode {
            get {
                return ResourceManager.GetString("C_UserMustBeNode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add _Notification method declaration.
        /// </summary>
        internal static string CodeFix_Notification {
            get {
                return ResourceManager.GetString("CodeFix_Notification", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Circular dependency detected: {0}.
        /// </summary>
        internal static string D_CircularDependencyDetected {
            get {
                return ResourceManager.GetString("D_CircularDependencyDetected", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Inject] member &apos;{0}&apos; requests type &apos;{1}&apos;, but no service exposes this type.
        /// </summary>
        internal static string D_InjectMemberTypeIsNotExposed {
            get {
                return ResourceManager.GetString("D_InjectMemberTypeIsNotExposed", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Scope &apos;{0}&apos; specifies no Services or Hosts in [Modules].
        /// </summary>
        internal static string D_ScopeModulesEmpty {
            get {
                return ResourceManager.GetString("D_ScopeModulesEmpty", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Scope &apos;{0}&apos; Modules Host type &apos;{1}&apos; must be a Host.
        /// </summary>
        internal static string D_ScopeModulesHostMustBeHost {
            get {
                return ResourceManager.GetString("D_ScopeModulesHostMustBeHost", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Scope &apos;{0}&apos; Modules Service type &apos;{1}&apos; must be a Service.
        /// </summary>
        internal static string D_ScopeModulesServiceMustBeService {
            get {
                return ResourceManager.GetString("D_ScopeModulesServiceMustBeService", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Service &apos;{0}&apos; has constructor parameter of type &apos;{1}&apos;, which is not a Service.
        /// </summary>
        internal static string D_ServiceConstructorParameterInvalid {
            get {
                return ResourceManager.GetString("D_ServiceConstructorParameterInvalid", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Service type &apos;{0}&apos; is registered by multiple providers: {1}. Each service type must have exactly one provider within a Scope.
        /// </summary>
        internal static string D_ServiceTypeConflict {
            get {
                return ResourceManager.GetString("D_ServiceTypeConflict", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Internal error in source generator: {0}.
        /// </summary>
        internal static string E_GeneratorInternalError {
            get {
                return ResourceManager.GetString("E_GeneratorInternalError", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Generator receives cancellation request: {0}.
        /// </summary>
        internal static string E_RequestCancellation {
            get {
                return ResourceManager.GetString("E_RequestCancellation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Scope &apos;{0}&apos; Unexpectedly loses [Modules] or [AutoModules].
        /// </summary>
        internal static string E_ScopeLosesAttributeUnexpectedly {
            get {
                return ResourceManager.GetString("E_ScopeLosesAttributeUnexpectedly", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Unknown DI Type Role.
        /// </summary>
        internal static string E_UnknownTypeRole {
            get {
                return ResourceManager.GetString("E_UnknownTypeRole", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Host &apos;{0}&apos; has no member marked as [Singleton].
        /// </summary>
        internal static string M_HostMissingSingletonMember {
            get {
                return ResourceManager.GetString("M_HostMissingSingletonMember", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Inject] member &apos;{0}&apos; has type &apos;{1}&apos;, which is a [Host] type. While allowed, injecting Host types directly is not recommended - consider injecting an interface exposed by the Host instead.
        /// </summary>
        internal static string M_InjectMemberIsHostType {
            get {
                return ResourceManager.GetString("M_InjectMemberIsHostType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Inject] member &apos;{0}&apos; has type &apos;{1}&apos;, which is an IScope type and cannot be injected.
        /// </summary>
        internal static string M_InjectMemberIsScopeType {
            get {
                return ResourceManager.GetString("M_InjectMemberIsScopeType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Inject] member &apos;{0}&apos; cannot be static.
        /// </summary>
        internal static string M_InjectMemberIsStatic {
            get {
                return ResourceManager.GetString("M_InjectMemberIsStatic", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Inject] member &apos;{0}&apos; has type &apos;{1}&apos;, which is a [User] type and cannot be injected.
        /// </summary>
        internal static string M_InjectMemberIsUserType {
            get {
                return ResourceManager.GetString("M_InjectMemberIsUserType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Inject] member &apos;{0}&apos; must be writable (field must not be readonly, property must have setter).
        /// </summary>
        internal static string M_InjectMemberNotAssignable {
            get {
                return ResourceManager.GetString("M_InjectMemberNotAssignable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Inject] member &apos;{0}&apos; has type &apos;{1}&apos;, which is not a valid injectable type. Injectable types must be interfaces or concrete classes (non-abstract, non-static).
        /// </summary>
        internal static string M_InjectMemberTypeIsInvalid {
            get {
                return ResourceManager.GetString("M_InjectMemberTypeIsInvalid", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Inject] member &apos;{0}&apos; has type &apos;{1}&apos; which is a concrete class. Consider using an interface instead for better testability and loose coupling.
        /// </summary>
        internal static string M_InjectMemberTypeShouldBeInterface {
            get {
                return ResourceManager.GetString("M_InjectMemberTypeShouldBeInterface", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Singleton] and [Inject] cannot be applied to the same member &apos;{0}&apos;.
        /// </summary>
        internal static string M_MemberConflictWithSingletonAndInject {
            get {
                return ResourceManager.GetString("M_MemberConflictWithSingletonAndInject", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; must be marked as [User] to use [Inject] on members.
        /// </summary>
        internal static string M_MemberHasInjectButNotInUser {
            get {
                return ResourceManager.GetString("M_MemberHasInjectButNotInUser", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; must be marked as [Host] to use [Singleton] on members.
        /// </summary>
        internal static string M_MemberHasSingletonButNotInHost {
            get {
                return ResourceManager.GetString("M_MemberHasSingletonButNotInHost", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Singleton] member &apos;{0}&apos; has exposed type &apos;{1}&apos;, but type &apos;{2}&apos; does not implement it.
        /// </summary>
        internal static string M_SingletonMemberExposedTypeNotImplemented {
            get {
                return ResourceManager.GetString("M_SingletonMemberExposedTypeNotImplemented", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Singleton] member exposed type &apos;{0}&apos; is a concrete class. Consider using an interface instead for better testability and loose coupling.
        /// </summary>
        internal static string M_SingletonMemberExposedTypeShouldBeInterface {
            get {
                return ResourceManager.GetString("M_SingletonMemberExposedTypeShouldBeInterface", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Singleton] member &apos;{0}&apos; has type &apos;{1}&apos;, which is a [Host] type. Host can only expose itself through [Singleton] members, not other Host types.
        /// </summary>
        internal static string M_SingletonMemberIsHostType {
            get {
                return ResourceManager.GetString("M_SingletonMemberIsHostType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Singleton] member &apos;{0}&apos; has type &apos;{1}&apos;, which is a regular Node (not marked with DI attributes) and cannot be used as a Singleton member.
        /// </summary>
        internal static string M_SingletonMemberIsRegularNode {
            get {
                return ResourceManager.GetString("M_SingletonMemberIsRegularNode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Singleton] member &apos;{0}&apos; has type &apos;{1}&apos;, which is an IScope type and cannot be used as a Singleton member.
        /// </summary>
        internal static string M_SingletonMemberIsScopeType {
            get {
                return ResourceManager.GetString("M_SingletonMemberIsScopeType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Singleton] member &apos;{0}&apos; has type &apos;{1}&apos;, which is already marked as a Service ([Singleton]). Host should not hold Service instances directly.
        /// </summary>
        internal static string M_SingletonMemberIsServiceType {
            get {
                return ResourceManager.GetString("M_SingletonMemberIsServiceType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Singleton] member &apos;{0}&apos; cannot be static.
        /// </summary>
        internal static string M_SingletonMemberIsStatic {
            get {
                return ResourceManager.GetString("M_SingletonMemberIsStatic", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Singleton] member &apos;{0}&apos; has type &apos;{1}&apos;, which is a [User] type and cannot be used as a Singleton member.
        /// </summary>
        internal static string M_SingletonMemberIsUserType {
            get {
                return ResourceManager.GetString("M_SingletonMemberIsUserType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Singleton] member &apos;{0}&apos; has type &apos;{1}&apos;, which is not a valid type. Singleton member types must be interfaces or concrete classes (non-abstract, non-static).
        /// </summary>
        internal static string M_SingletonMemberTypeIsInvalid {
            get {
                return ResourceManager.GetString("M_SingletonMemberTypeIsInvalid", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to [Singleton] property &apos;{0}&apos; must have a getter.
        /// </summary>
        internal static string M_SingletonPropertyNotAccessible {
            get {
                return ResourceManager.GetString("M_SingletonPropertyNotAccessible", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to User &apos;{0}&apos; has no member marked as [Inject].
        /// </summary>
        internal static string M_UserMissingInjectMember {
            get {
                return ResourceManager.GetString("M_UserMissingInjectMember", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Service &apos;{0}&apos; has multiple constructors, should specify unique [InjectConstructor].
        /// </summary>
        internal static string S_AmbiguousConstructor {
            get {
                return ResourceManager.GetString("S_AmbiguousConstructor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; is not a Service but uses [InjectConstructor].
        /// </summary>
        internal static string S_InjectConstructorAttributeIsInvalid {
            get {
                return ResourceManager.GetString("S_InjectConstructorAttributeIsInvalid", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constructor parameter &apos;{0}&apos; has type &apos;{1}&apos;, which is not a valid injectable type. Injectable types must be interfaces or concrete classes (non-abstract, non-static, non-Node).
        /// </summary>
        internal static string S_InjectConstructorParameterTypeInvalid {
            get {
                return ResourceManager.GetString("S_InjectConstructorParameterTypeInvalid", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constructor parameter &apos;{0}&apos; has type &apos;{1}&apos;, which is a [Host] type. While allowed, injecting Host types is not recommended - consider injecting an interface instead.
        /// </summary>
        internal static string S_InjectCtorParamIsHostType {
            get {
                return ResourceManager.GetString("S_InjectCtorParamIsHostType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constructor parameter &apos;{0}&apos; has type &apos;{1}&apos;, which is a regular Node (not marked with DI attributes) and cannot be injected.
        /// </summary>
        internal static string S_InjectCtorParamIsRegularNode {
            get {
                return ResourceManager.GetString("S_InjectCtorParamIsRegularNode", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constructor parameter &apos;{0}&apos; has type &apos;{1}&apos;, which is an IScope type and cannot be injected.
        /// </summary>
        internal static string S_InjectCtorParamIsScopeType {
            get {
                return ResourceManager.GetString("S_InjectCtorParamIsScopeType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constructor parameter &apos;{0}&apos; has type &apos;{1}&apos;, which is a [User] type and cannot be injected.
        /// </summary>
        internal static string S_InjectCtorParamIsUserType {
            get {
                return ResourceManager.GetString("S_InjectCtorParamIsUserType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constructor parameter &apos;{0}&apos; has type &apos;{1}&apos; which is a concrete class. Consider using an interface instead for better testability.
        /// </summary>
        internal static string S_InjectCtorParamTypeShouldBeInterface {
            get {
                return ResourceManager.GetString("S_InjectCtorParamTypeShouldBeInterface", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Service &apos;{0}&apos; must define at least one non-static constructor.
        /// </summary>
        internal static string S_NoNonStaticConstructor {
            get {
                return ResourceManager.GetString("S_NoNonStaticConstructor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not manually access generated field &apos;{0}&apos; on &apos;{1}&apos;. This field is managed by the DI framework and should not be accessed directly by user code.
        /// </summary>
        internal static string U_ManualAccessGeneratedField {
            get {
                return ResourceManager.GetString("U_ManualAccessGeneratedField", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not manually access generated property &apos;{0}&apos; on &apos;{1}&apos;. This property is managed by the DI framework and should not be accessed directly by user code.
        /// </summary>
        internal static string U_ManualAccessGeneratedProperty {
            get {
                return ResourceManager.GetString("U_ManualAccessGeneratedProperty", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not manually call generated method &apos;{0}&apos; on &apos;{1}&apos;. This method is managed by the DI framework and will be called automatically at the appropriate time.
        /// </summary>
        internal static string U_ManualCallGeneratedMethod {
            get {
                return ResourceManager.GetString("U_ManualCallGeneratedMethod", resourceCulture);
            }
        }
    }
}
