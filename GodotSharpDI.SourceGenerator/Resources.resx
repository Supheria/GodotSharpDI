<?xml version="1.0" encoding="utf-8"?>

<root>
    <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
        <xsd:element name="root" msdata:IsDataSet="true">

        </xsd:element>
    </xsd:schema>
    <resheader name="resmimetype">
        <value>text/microsoft-resx</value>
    </resheader>
    <resheader name="version">
        <value>1.3</value>
    </resheader>
    <resheader name="reader">
        <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
    </resheader>
    <resheader name="writer">
        <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
    </resheader>

    <!-- ============================================================ -->
    <!-- C — Class-level Diagnostics -->
    <!-- ============================================================ -->

    <data name="C_HostInvalidAttribute" xml:space="preserve">
        <value>Host '{0}' cannot use [{1}]</value>
    </data>

    <data name="C_UserInvalidAttribute" xml:space="preserve">
        <value>User '{0}' cannot use [{1}]</value>
    </data>

    <data name="C_ScopeInvalidAttribute" xml:space="preserve">
        <value>Scope '{0}' cannot use [{1}]</value>
    </data>

    <data name="C_OnlyScopeCanUseModules" xml:space="preserve">
        <value>To use [Modules], Type '{0}' must implement IScope</value>
    </data>

    <data name="C_HostMustBeNode" xml:space="preserve">
        <value>Host '{0}' must inherit from Godot.Node</value>
    </data>

    <data name="C_UserMustBeNode" xml:space="preserve">
        <value>User '{0}' must inherit from Godot.Node</value>
    </data>

    <data name="C_ScopeMustBeNode" xml:space="preserve">
        <value>Scope '{0}' must inherit from Godot.Node</value>
    </data>

    <data name="C_ServiceReadyNeedUser" xml:space="preserve">
        <value>Type '{0}' implements IServicesReady but is not marked with [User]</value>
    </data>

    <data name="C_ScopeMissingModules" xml:space="preserve">
        <value>Scope '{0}' must specify [Modules]</value>
    </data>

    <data name="C_DiClassMustBePartial" xml:space="preserve">
        <value>DI-relative class '{0}' must be declared as partial to enable code generation</value>
    </data>

    <data name="C_ServiceTypeIsInvalid" xml:space="preserve">
        <value>Service '{0}' cannot inherit from Godot.Node, and must be non-abstract, non-static class type</value>
    </data>

    <data name="C_ServiceExposedTypeShouldBeInterface" xml:space="preserve">
        <value>Service '{0}' exposed type '{1}' is a concrete class. Consider using an interface instead for better testability and loose coupling</value>
    </data>

    <data name="C_ServiceExposedTypeNotImplemented" xml:space="preserve">
        <value>Service '{0}' has exposed type '{1}', but which is not implemented</value>
    </data>

    <data name="C_MissingNotificationMethod" xml:space="preserve">
        <value>Type '{0}' must define 'public override partial void _Notification(int what);' in the script file attached to Node. This method is required for DI framework lifecycle management</value>
    </data>

    <data name="C_InvalidNotificationMethodSignature" xml:space="preserve">
        <value>Type '{0}' has incorrect _Notification method signature. Expected: 'public override partial void _Notification(int what);'</value>
    </data>

    <!-- ============================================================ -->
    <!-- M — Member-level Diagnostics -->
    <!-- ============================================================ -->

    <data name="M_MemberHasSingletonButNotInHost" xml:space="preserve">
        <value>Type '{0}' must be marked as [Host] to use [Singleton] on members</value>
    </data>

    <data name="M_MemberHasInjectButNotInUser" xml:space="preserve">
        <value>Type '{0}' must be marked as [User] to use [Inject] on members</value>
    </data>

    <data name="M_MemberConflictWithSingletonAndInject" xml:space="preserve">
        <value>[Singleton] and [Inject] cannot be applied to the same member '{0}'</value>
    </data>

    <data name="M_InjectMemberNotAssignable" xml:space="preserve">
        <value>[Inject] member '{0}' must be writable (field must not be readonly, property must have setter)</value>
    </data>

    <data name="M_SingletonPropertyNotAccessible" xml:space="preserve">
        <value>[Singleton] property '{0}' must have a getter</value>
    </data>

    <data name="M_InjectMemberIsStatic" xml:space="preserve">
        <value>[Inject] member '{0}' cannot be static</value>
    </data>

    <data name="M_InjectMemberTypeIsInvalid" xml:space="preserve">
        <value>[Inject] member '{0}' has type '{1}', which is not a valid injectable type. Injectable types must be interfaces or concrete classes (non-abstract, non-static)</value>
    </data>

    <data name="M_InjectMemberIsHostType" xml:space="preserve">
        <value>[Inject] member '{0}' has type '{1}', which is a [Host] type. While allowed, injecting Host types directly is not recommended - consider injecting an interface exposed by the Host instead</value>
    </data>

    <data name="M_InjectMemberIsUserType" xml:space="preserve">
        <value>[Inject] member '{0}' has type '{1}', which is a [User] type and cannot be injected</value>
    </data>

    <data name="M_InjectMemberIsScopeType" xml:space="preserve">
        <value>[Inject] member '{0}' has type '{1}', which is an IScope type and cannot be injected</value>
    </data>

    <data name="M_InjectMemberTypeShouldBeInterface" xml:space="preserve">
        <value>[Inject] member '{0}' has type '{1}' which is a concrete class. Consider using an interface instead for better testability and loose coupling</value>
    </data>

    <data name="M_SingletonMemberIsStatic" xml:space="preserve">
        <value>[Singleton] member '{0}' cannot be static</value>
    </data>

    <data name="M_SingletonMemberTypeIsInvalid" xml:space="preserve">
        <value>[Singleton] member '{0}' has type '{1}', which is not a valid type. Singleton member types must be interfaces or concrete classes (non-abstract, non-static)</value>
    </data>

    <data name="M_SingletonMemberIsServiceType" xml:space="preserve">
        <value>[Singleton] member '{0}' has type '{1}', which is already marked as a Service ([Singleton]). Host should not hold Service instances directly</value>
    </data>

    <data name="M_SingletonMemberIsHostType" xml:space="preserve">
        <value>[Singleton] member '{0}' has type '{1}', which is a [Host] type. Host can only expose itself through [Singleton] members, not other Host types</value>
    </data>

    <data name="M_SingletonMemberIsUserType" xml:space="preserve">
        <value>[Singleton] member '{0}' has type '{1}', which is a [User] type and cannot be used as a Singleton member</value>
    </data>

    <data name="M_SingletonMemberIsScopeType" xml:space="preserve">
        <value>[Singleton] member '{0}' has type '{1}', which is an IScope type and cannot be used as a Singleton member</value>
    </data>

    <data name="M_SingletonMemberIsRegularNode" xml:space="preserve">
        <value>[Singleton] member '{0}' has type '{1}', which is a regular Node (not marked with DI attributes) and cannot be used as a Singleton member</value>
    </data>

    <data name="M_SingletonMemberExposedTypeNotImplemented" xml:space="preserve">
        <value>[Singleton] member '{0}' has exposed type '{1}', but type '{2}' does not implement it</value>
    </data>

    <data name="M_SingletonMemberExposedTypeShouldBeInterface" xml:space="preserve">
        <value>[Singleton] member exposed type '{0}' is a concrete class. Consider using an interface instead for better testability and loose coupling</value>
    </data>

    <data name="M_HostMissingSingletonMember" xml:space="preserve">
        <value>Host '{0}' has no member marked as [Singleton]</value>
    </data>

    <data name="M_UserMissingInjectMember" xml:space="preserve">
        <value>User '{0}' has no member marked as [Inject]</value>
    </data>

    <!-- ============================================================ -->
    <!-- S — Constructor-level Diagnostics -->
    <!-- ============================================================ -->

    <data name="S_NoNonStaticConstructor" xml:space="preserve">
        <value>Service '{0}' must define at least one non-static constructor</value>
    </data>

    <data name="S_AmbiguousConstructor" xml:space="preserve">
        <value>Service '{0}' has multiple constructors, should specify unique [InjectConstructor]</value>
    </data>

    <data name="S_InjectConstructorAttributeIsInvalid" xml:space="preserve">
        <value>Type '{0}' is not a Service but uses [InjectConstructor]</value>
    </data>

    <data name="S_InjectConstructorParameterTypeInvalid" xml:space="preserve">
        <value>Constructor parameter '{0}' has type '{1}', which is not a valid injectable type. Injectable types must be interfaces or concrete classes (non-abstract, non-static, non-Node)</value>
    </data>

    <data name="S_InjectCtorParamIsHostType" xml:space="preserve">
        <value>Constructor parameter '{0}' has type '{1}', which is a [Host] type. While allowed, injecting Host types is not recommended - consider injecting an interface instead</value>
    </data>

    <data name="S_InjectCtorParamIsUserType" xml:space="preserve">
        <value>Constructor parameter '{0}' has type '{1}', which is a [User] type and cannot be injected</value>
    </data>

    <data name="S_InjectCtorParamIsScopeType" xml:space="preserve">
        <value>Constructor parameter '{0}' has type '{1}', which is an IScope type and cannot be injected</value>
    </data>

    <data name="S_InjectCtorParamIsRegularNode" xml:space="preserve">
        <value>Constructor parameter '{0}' has type '{1}', which is a regular Node (not marked with DI attributes) and cannot be injected</value>
    </data>

    <data name="S_InjectCtorParamTypeShouldBeInterface" xml:space="preserve">
        <value>Constructor parameter '{0}' has type '{1}' which is a concrete class. Consider using an interface instead for better testability</value>
    </data>

    <!-- ============================================================ -->
    <!-- D — Dependency Graph Diagnostics -->
    <!-- ============================================================ -->

    <data name="D_ScopeModulesEmpty" xml:space="preserve">
        <value>Scope '{0}' specifies no Services or Hosts in [Modules]</value>
    </data>

    <data name="D_ScopeModulesServiceMustBeService" xml:space="preserve">
        <value>Scope '{0}' Modules Service type '{1}' must be a Service</value>
    </data>

    <data name="D_ScopeModulesHostMustBeHost" xml:space="preserve">
        <value>Scope '{0}' Modules Host type '{1}' must be a Host</value>
    </data>

    <data name="D_CircularDependencyDetected" xml:space="preserve">
        <value>Circular dependency detected: {0}</value>
    </data>

    <data name="D_ServiceConstructorParameterInvalid" xml:space="preserve">
        <value>Service '{0}' has constructor parameter of type '{1}', which is not a Service</value>
    </data>

    <data name="D_ServiceTypeConflict" xml:space="preserve">
        <value>Service type '{0}' is registered by multiple providers: {1}. Each service type must have exactly one provider within a Scope</value>
    </data>

    <data name="D_InjectMemberTypeIsNotExposed" xml:space="preserve">
        <value>[Inject] member '{0}' requests type '{1}', but no service exposes this type</value>
    </data>

    <!-- ============================================================ -->
    <!-- E — Internal Error Diagnostics -->
    <!-- ============================================================ -->

    <data name="E_RequestCancellation" xml:space="preserve">
        <value>Generator receives cancellation request: {0}</value>
    </data>

    <data name="E_GeneratorInternalError" xml:space="preserve">
        <value>Internal error in source generator: {0}</value>
    </data>

    <data name="E_UnknownTypeRole" xml:space="preserve">
        <value>Unknown DI Type Role</value>
    </data>

    <data name="E_ScopeLosesAttributeUnexpectedly" xml:space="preserve">
        <value>Scope '{0}' Unexpectedly loses [Modules] or [AutoModules]</value>
    </data>

    <!-- ============================================================ -->
    <!-- U — User Behavior Diagnostics -->
    <!-- ============================================================ -->

    <data name="U_ManualCallGeneratedMethod" xml:space="preserve">
        <value>Do not manually call generated method '{0}' on '{1}'. This method is managed by the DI framework and will be called automatically at the appropriate time</value>
    </data>

    <data name="U_ManualAccessGeneratedField" xml:space="preserve">
        <value>Do not manually access generated field '{0}' on '{1}'. This field is managed by the DI framework and should not be accessed directly by user code</value>
    </data>

    <data name="U_ManualAccessGeneratedProperty" xml:space="preserve">
        <value>Do not manually access generated property '{0}' on '{1}'. This property is managed by the DI framework and should not be accessed directly by user code</value>
    </data>

    <!-- ============================================================ -->
    <!-- Code Fix Messages -->
    <!-- ============================================================ -->

    <data name="CodeFix_Notification" xml:space="preserve">
        <value>Add _Notification method declaration</value>
    </data>

</root>
